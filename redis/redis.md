# redis

参考: https://pdai.tech/md/db/nosql-redis/db-redis-overview.html

# 基础概念

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。

支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

五种基本数据类型
- String
- List
- Set
- Zset
- Hash

四种特殊数据类型
- HyperLogLogs(基数统计) 
- Bitmaps(位图)
- geospatial(地理位置)
- Stream

# 使用场景

## 数据缓存

作为缓存使用时，一般有两种方式保存数据：

### 方案一

先读Redis，如果没有数据，读取数据库，将数据拉入Redis

实施起来简单，但是有两个需要注意的地方：
- 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
- 数据的实时性相对会差一点,适用于对数据实时性要求不是特别高的场景

### 方案二

插入数据时，同时写入Redis

数据实时性强，但是开发时不便于统一处理,适用于字典表、数据量不大的数据存储。

## 限时业务

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景

## 计数器

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等

## 分布式锁

这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。在分布式锁的场景中，主要用在比如秒杀系统等

## 排行榜

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的

## 简单队列

由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作

# 版本特性

https://pdai.tech/md/db/nosql-redis/db-redis-x-version-lastest.html