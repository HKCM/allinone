# Redis持久化

## RDB

RDB 就是 Redis DataBase 的缩写, RDB持久化是把当前进程数据生成快照保存到磁盘上的过程. 

由于是某一时刻的快照，那么快照中的值必定是早于或者等于内存中的值。

触发rdb持久化的方式有2种，分别是手动触发和自动触发

### 手动触发

手动触发分别对应save和bgsave命令
- save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用
- bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短

### 自动触发

以下4种情况时会自动触发:
- redis.conf中配置`save m n`，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；
- 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
- 执行debug reload命令重新加载redis时也会触发bgsave操作；
- 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

### RDB配置
redis.conf配置RDB快照周期

```ini
# 默认的设置为：
save 900 1 # 如果900秒内有1条Key信息发生变化，则进行快照；
save 300 10 # 如果300秒内有10条Key信息发生变化，则进行快照；
save 60 10000 # 如果60秒内有10000条Key信息发生变化，则进行快照

dir /home/work/app/redis/data/ # 文件保存路径 默认设置为“./”，也就是Redis服务的主目录
dbfilename dump.rdb # RDB文件名称

stop-writes-on-bgsave-error yes # 如果持久化出错，主进程是否停止写入
rdbcompression yes # 是否压缩
rdbchecksum yes # 导入时是否检查

save "" # 关闭RDB快照功能
```

### bgsave过程

1. 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回
2. 如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作
3. fork采用的是copy-on-write技术
   - 当主进程执行读操作时，访问共享内存；
   - 当主进程执行写操作到现有Key时，则会开辟新的内存空间拷贝原数据，执行写操作。
   - 可能导致内存使用量增加
4. 当主进程执行写操作到现有Key时，则会开辟新的内存空间拷贝原数据，执行写操作。
5. 子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件
6. 同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）

在RDB写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。

### RDB优缺点

优点:
- RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景
- Redis加载RDB文件恢复数据要远远快于AOF方式

缺点: 
- RDB方式实时性不够，无法做到秒级的持久化；
- 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
- RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
- 版本兼容RDB文件问题；
 
针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决


## AOF

AOF全称为Append Only File(追加文件)。Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的，可以看做是命令日志文件。

因为是记录命令，AOF会记录对同一个key的多次写操作(但一般来说只有最后一次写操作才有意义),所以AOF文件会比RDB文件大的多。

通过执行`bgrewriteaof`命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

```bash
SET a 1
SET a 12
DECRBY a 7
SET a 5 # 实际只需要这个语句
```

### 写后日志

AOF日志采用**写后日志**，即先写内存，后写日志。

Redis要求高性能，采用写日志有两方面好处：
- 避免额外的检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
- 不会阻塞当前的写操作

潜在风险：
- 如果命令执行完成，写日志之前宕机了，会丢失数据。
- 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。

### AOF实现

AOF日志记录Redis的每个写命令，步骤分为：
- 命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。
- 缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。
- 文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， fsync 函数或者 fdatasync 函数会被调用，将写入的内容真正地保存到磁盘中

Redis 目前支持三种 AOF 保存模式，它们分别是：
- AOF_FSYNC_NO: 操作系统控制的写回,每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
- AOF_FSYNC_EVERYSEC: 每秒写回,每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘
- AOF_FSYNC_ALWAYS: 同步写回,每个写命令执行完，立马同步地将日志写回磁盘；

### AOF配置

```ini
appendonly no # appendonly参数开启AOF持久化
appendfilename "appendonly.aof" # AOF持久化的文件名，默认是appendonly.aof
dir ./ # AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的

# 同步策略
# appendfsync always
appendfsync everysec # 默认值
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
# 例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作
auto-aof-rewrite-percentage 100 
# 置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

aof-rewrite-incremental-fsync yes # 文件重写策略
```

AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。

AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。所以aof在重写时，在fork进程时是会阻塞住主线程的。

在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。

## RDB和AOF

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。


# 恢复数据

恢复数据，只需要重新启动Redis即可

1. redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；
2. 如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；
3. 若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；
4. 如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；

之所以会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析可以知道AOF基本上最多损失1s的数据。

# 性能与实践

通过上面的分析，可以知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。

因此为了不影响Redis主进程响应，需要尽可能降低阻塞。

1. 降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；
2. 控制Redis最大使用内存，防止fork耗时过长；
3. 使用更好的硬件；
4. 合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。
 
线上环境

1. 如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；
2. 自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；
3. 单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；
4. 可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；RDB持久化与AOF持久化可以同时存在，配合使用

# 安全性

当使用主从,哨兵或集群模式时,不开启持久化是危险的,例如

1. 设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。
2. 此时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。
3. 由于节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。

当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。

如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启