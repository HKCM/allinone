## 视图(VIEW):  
- 虚拟存在的表，不保存查询结果，只保存查询的SQL逻辑
- 简单、安全(隐藏数据,只显示所需数据)、 数据独立(数据基表发生变化后只需要修改视图的字段名)

## 存储过程(PROCEDURE):
- 事先定义并存储在数据库中的一段SQL语句的集合。 需要用到的时候直接调用即可。
- 可以接收参数，也可以返回数据
- 减少网络交互，提高性能、封装重用 
- 支持逻辑处理,变量、if、case、参数(in/out/inout)、while、repeat、loop、cursor、 handler
- 业务逻辑相对稳定但比较复杂，而且对数据的正确性和完整性要求比较高时，推荐在主要的业务逻辑中使用存储过程。

缺点:
1. 如果想灰度发布，同时存在不同版本的存储过程给不同用户用，这个很难或者没法做
2. 存储过程的源码版本管理肯定不像写传统的java等代码直接方便，需要额外的工具和机制，版本跟踪，版本部署等都需要额外的工作

### 存储函数(FUNCTION):
- 存储函数是有返回值的存储过程，参数类型只能为N类型
- 存储函数可以被存储过程替代

### 触发器(TRIGGER):
- 可以在表数据进行INSERT、UPDATE、DELETE之前或之后触发
- 保证数据完整性、日志记录、数据校验
- 只支持行级触发，不支持语句级触发
- 触发器不推荐使用，触发操作能在业务层解决就在业务层解决，否则很难维护，而且容易产生死锁


## 事务

### 事务隔离级别

[迸发事务问题演示](https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55&vd_source=590cb3e34e1ca2883a1019e924794619)

- 脏读: 一个事务读到另外一个事务还没有提交的数据。
- 不可重复读: 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
- 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了” 幻影”。

隔离级别
- Read uncommitted
- Read committed
- Repeatable Read(默认)
- Serializable

```sql
-- 查询隔离级别
SELECT @@TRANSACTION_ISOLATION;

-- 设置事务隔离级别 
-- SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL [ READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE ]
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

## 索引相关

### 以下SQL语句，那个执行效率高？为什么？
```sql
SELECT * FROM user WHERE id =10; -- 聚集索引一次查询即可获得数据
SELECT * FROM user WHERE name ='Arm';  -- 需要回表查询
-- 备注:id为主键,name字段创建的有索引;
```

### InnoDB主键索引的B+tree高度为多高呢？
假设： 
- 一行数据大小为1k，一页中可以存储16行这样的数据。
- InnoDB的指针占用6 个字节的空间，主键即使为bigint，占用字节数为8。 
  - 如果高度为2: nX8+(n+1)X6=16X1024，算出n约为1170.即有1171个指针(对应1171个字节点(页)).
  - 一页16K,可以存16条数据 1171X16=18736条数据
  - 如果高度为3: nX8+(n+1)X6=16X1024，算出n约为1170.即第一层有1171个指针(对应1171个字节点(页)).
  - 那么第二层又可以有1171个字节点(页) 1171X1171=1,371,241
  - 一页16K,可以存16条数据 1371241X16=21,939,856条数据

### SQL语句进行优化

一张表，有四个字段(id，username，password，status) 由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： 
```sql
select id，username，password from tb_user where username ='itcast';
```
两种方案:
1. 如果id是主键,建立username和password的联合索引 username 在前
2. 使用username作为主键

### 为什么InnoDB存储引擎选择使用B+tree索引结构？
1. 相对于二叉树，层级更少，搜索效率高；
2. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
3. 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。B+Tree的查询效率更加稳定
4. 原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。
5. 相对Hash索引，B+tree支持范围匹配及排序操作；

### 最左前缀法则

最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。

### 联合索引范围查询

联合索引中，出现范围查询(`>`，`<`)，范围查询右侧的列索引失效, 在业务允许的情况下，尽可能的使用类似于 `>=` 或 `<=` 这类的范围查询，而避免使用 `>` 或 `<`

### 索引失效的情况
1. 联合索引没包含最左前缀
2. 索引列上进行运算操作
3. 头部模糊匹配
4. 字符串条件没加引号
5. or 字段没有索引
6. in 走索引， not in 索引失效。


### 索引设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。(大于10000条数据)
2. 针对于常作为查询条件(where)、排序(ORDER BY)、分组(GROUP BY)操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

### 主键设计原则

- 满足业务需求的情况下，尽量降低主键的长度。因为二级索引的叶子结点中挂的就是主键,所以主键长度低可以节省空间
- 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。乱序插入可能页分裂.
- 业务操作尽量避免对主键的修改

### SQL性能分析
- 慢查询日志
- profile详情
- explain执行计划

# 优化

## 减少网络交互

### 批量提交

数据库访问框架一般都提供了批量提交的接口，jdbc支持batch的提交处理方法。

例如当一次性要往一个表中插入1000万条数据时，如果采用普通的executeUpdate处理，那么和服务器交互次数为1000万次，按每秒钟可以向数据库服务器提交10000次估算，要完成所有工作需要1000秒。如果采用批量提交模式，1000条提交一次，那么和服务器交互次数为1万次，交互次数大大减少。

采用batch操作一般不会减少很多数据库服务器的物理IO，但是会大大减少客户端与服务端的交互次数，从而减少了多次发起的网络延时开销，同时也会降低数据库的CPU开销。

### in list

```sql
select * from mytable where id in(:id1,id2,...,idn);
```

通过in处理可以大大减少SQL请求的数量，从而提高性能。

但是当IN数量达到一定值时有可能改变SQL执行计划，从索引访问变成全表访问，这将使性能急剧变化。随着SQL中IN的里面的值个数增加，SQL的执行计划会更复杂，占用的内存将会变大，这将会增加服务器CPU及内存成本。

综合考虑，一般IN里面的值个数超过20个以后性能基本没什么太大变化，也特别说明不要超过100，超过后可能会引起执行计划的不稳定性及增加数据库CPU及内存成本

### fetch size

当采用select从数据库查询数据时，数据默认并不是一条一条返回给客户端的，也不是一次全部返回客户端的，而是根据客户端fetch_size参数处理，每次只返回fetch_size条记录，当客户端游标遍历到尾部时再从服务端取数据，直到最后全部传送完成。所以如果要从服务端一次取大量数据时，可以加大fetch_size，这样可以减少结果数据传输的交互次数及服务器数据准备时间，提高性能。

### 存储过程

大型数据库一般都支持存储过程，合理的利用存储过程也可以提高系统性能。

如你有一个业务需要将A表的数据做一些加工然后更新到B表中，但是又不可能一条SQL完成，这时你需要如下3步操作：

a：将A表数据全部取出到客户端；
b：计算出要更新的数据；
c：将计算结果更新到B表。

如果采用存储过程你可以将整个业务逻辑封装在存储过程里，然后在客户端直接调用存储过程处理，这样可以减少网络交互的成本。

存储过程也并不是十全十美，存储过程有以下缺点：

a、不可移植性，每种数据库的内部编程语法都不太相同，当你的系统需要兼容多种数据库时最好不要用存储过程。
b、学习成本高，DBA一般都擅长写存储过程，但并不是每个程序员都能写好存储过程，除非你的团队有较多的开发人员熟悉写存储过程，否则后期系统维护会产生问题。
c、业务逻辑多处存在，采用存储过程后也就意味着你的系统有一些业务逻辑不是在应用程序里处理，这种架构会增加一些系统维护和调试成本。
d、存储过程和常用应用程序语言不一样，它支持的函数及语法有可能不能满足需求，有些逻辑就只能通过应用程序处理。
e、如果存储过程中有复杂运算的话，会增加一些数据库服务端的处理成本，对于集中式数据库可能会导致系统可扩展性问题。
f、为了提高性能，数据库会把存储过程代码编译成中间运行代码(类似于java的class文件)，所以更像静态语言。当存储过程引用的对像(表、视图等等)结构改变后，存储过程需要重新编译才能生效，在24*7高并发应用场景，一般都是在线变更结构的，所以在变更的瞬间要同时编译存储过程，这可能会导致数据库瞬间压力上升引起故障(Oracle数据库就存在这样的问题)。

个人观点：普通业务逻辑尽量不要使用存储过程，定时性的ETL任务或报表统计函数可以根据团队资源情况采用存储过程处理。